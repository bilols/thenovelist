# The Novelist – Three-Phase Implementation Plan

## Phase 1 – Continuity Recovery

### Objectives

* Eliminate character/name drift (e.g. Ethan ↔ Ian, Mr Porter ↔ Henry).
* Store premise and key metadata in one place; propagate it to every phase.
* Integrate characters into story arc and beats via canonical IDs (consistent references).
* Add basic validation to catch cross-phase continuity mismatches.

### Key Tasks and Changes

* **Project/Premise:** Introduce a `ProjectMetadata` structure (containing the story premise, genre, audience/style) and embed it at the top of the outline JSON. Update the outline schema (`outline.schema.v1.json`) and the initialization in `Program.cs` (and related model classes) to include this metadata. This ensures the expanded premise and settings are stored once and passed into all subsequent generation prompts (so later phases use the enriched premise text, not a stale or truncated version).
* **Characters:** Reorder the CLI workflow so that character generation occurs *before* the story arc definition. In `Program.cs`, call the `CharacterGeneratorService` prior to the arc generation. This produces a canonical list of characters (with fixed names and IDs) that subsequent phases can reference. Adjust `CharacterGeneratorService.cs` if needed to ensure its output is available globally (e.g. saved into the outline or a context object) for the arc and beyond.
* **Story Arc:** Revise the `ArcDefinerService` to incorporate the canonical characters from the project metadata when building the arc prompt. The arc-generation prompt should reference the existing character names (for example, by listing the protagonist and important characters) and explicitly instruct the LLM not to invent new character names. This change prevents the arc phase from introducing untracked characters (addressing issues like the protagonist being renamed in the arc).
* **Schema Linking:** Extend the outline schema to add character cross-references. For each story act and each beat, include a `characterIds` array that links to characters involved in that segment. Update the JSON schema file (`tools/outline.schema.v1.json`) and any outline parsing/serialization code to handle this new field. As characters are introduced or referenced in an act or beat, record their unique IDs in these arrays – this creates an explicit link ensuring, for example, that if a beat involves the protagonist and a side character, the beat JSON will list their IDs. This structural tagging will later help in consistency checks and prompt building.
* **Validation:** Enhance the project’s artifact validation step to catch continuity errors early. Update or extend the validation script/tests (e.g. `tests/validate_artifacts.py`) to flag any act or beat that contains a character name not defined in the master character list, as well as any broken references (e.g. beats referring to subplot IDs that don’t exist). This basic validation will act as a guardrail by failing fast if the pipeline ever produces an outline with inconsistent character naming or missing links, forcing the issues to be fixed before drafting.

## Phase 2 – Prompt Scaffolding & Guard-rails

### Objectives

* Preserve full context (characters, beats, subplots) in every generation prompt.
* Prevent omission of required beats or subplot events in the story.
* Introduce checklist-style prompts and automated retries to address missing content.

### Key Tasks and Changes

* **Subplots:** Add a new `SubPlotGeneratorService` to handle subplot generation. This service will run after the main story arc (and character list) is defined, creating a set of subplot threads for the story. Each subplot should have an identifier (e.g. S1, S2, S3) and a short description. Store these in a top-level `subplots` array in the outline JSON (schema update required to add `subplots[]`). Additionally, update each act in the `storyArc` to reference which subplot IDs are active in that act (or incorporate subplot cues into act content). These subplot IDs will be used in later prompts to maintain continuity of each subplot’s storyline across chapters.
* **Beats:** Overhaul the beat expansion process to be iterative and context-rich. Instead of prompting the LLM for a full list of beats all at once per act, generate beats one at a time or in small sequential batches to maintain coherence. Modify the Beat generation logic so that **each beat prompt includes**: (a) the previous beat’s text (to maintain chronological continuity), (b) tags or a list of characters involved in the next scene, and (c) the specific subplot line or ID that the beat should address (if any). Also extend the beat data model to include new fields for context: for example, add a `characters` field (listing the IDs or names of characters in the beat) and a `subplotId` field (linking the beat to a subplot thread). This ensures each generated beat is aware of *who* is in the scene and *what subplot* it should advance, reducing the chance that the LLM will omit key plot points or character interactions.
* **Chapter Context Assembly:** Introduce a `ChapterContextBuilder` utility to prepare comprehensive context for each chapter during outline structuring. This component will gather all relevant information for a chapter before drafting begins. For each chapter, collate a brief recap of the premise or current situation, the act summary it belongs to, the specific beats assigned to that chapter (with their subplot tags), and a "cheat-sheet" of the main characters (including names and a short note on their traits or current state). Integrate this builder into `StructureOutlinerService` (or wherever chapters are planned) so that the outline carries forward a rich context bundle per chapter. By structuring the outline this way, when it comes time to draft, the system can feed the model exactly what it needs for that chapter’s content.
* **Draft Prompts:** Improve the prompt construction for the drafting phase so that the model is explicitly guided by the outline details. In `DraftBuilderService.BuildPiecePrompt`, remove the ambiguous line that says “Remaining beats: N” and replace it with a concrete list or summary of the remaining beats **for that chapter**. For example, if Chapter 7 has three beats named “A”, “B”, “C” in the outline, the prompt should explicitly enumerate them (or at least reference them by ID and description) so the model knows what must be covered. Additionally, include reminders of character traits or arcs in the prompt: e.g. *“Characters in this chapter: Ethan (protagonist, anxious about the past), Martha (wise, observant elder)”*. This way, the model is less likely to drift on character personalities or forget interpersonal dynamics. By making the drafting prompts checklist-oriented and specific, we ensure the generated prose addresses every outline point (as was practiced in earlier prototypes with success).
* **Guard-rails & Validation:** Implement runtime checks to enforce that no critical outline elements are skipped during drafting. Extend the existing duplicate content detector (if one exists) to cover narrative repetition or contradictions. More importantly, add a `BeatCoverageValidator` mechanism that runs after each chapter draft is generated to verify that all beats intended for that chapter actually appear or are acknowledged in the text. If the validator finds that a beat or subplot event was omitted, the system should automatically trigger a revision: for instance, it could prompt the model again to add the missing piece, or re-generate the chapter with a stronger hint for that content. This may involve looping within the drafting function for a limited number of retries until the chapter passes validation. Implement configuration controls (see Phase 3) for how many retries are allowed. The guardrail ensures that the pipeline doesn’t silently drop important story events – any such omission will be caught and corrected in the moment, rather than leaving a gap in the final manuscript.

## Phase 3 – Fidelity Enforcement & Polishing

### Objectives

* Guarantee that the final manuscript covers **every** outline beat and subplot thread.
* Add automated post-draft quality assurance and report metrics (e.g. cost, consistency).
* Expose user-tunable settings (e.g. retry limits, chapter size, POV style enforcement) for flexibility.

### Key Tasks and Changes

* **Drafting Engine Refinement:** Refactor the draft generation process to produce the novel chapter by chapter, injecting relevant outline context at each step. In `DraftBuilderService.cs` (or the main drafting workflow), implement a loop that goes through each chapter of the outline sequentially. For each chapter, use the prepared context (from the `ChapterContextBuilder`) to prompt the model, and also include a brief recap of the previous chapter’s ending if needed to maintain narrative continuity between chapters (ensuring transitions are smooth and logical). This chunked drafting approach prevents the model from being overwhelmed with the entire outline at once and helps maintain focus on the current section while still respecting the global storyline. It also makes it easier to pinpoint and fix issues chapter-by-chapter.
* **Post-Draft Validation & QA:** After the full draft (all chapters) is generated, perform an automated consistency check against the outline. Implement a new `DraftValidator` module that will parse the final manuscript and cross-check it with the outline’s beats and subplots. For each beat and subplot, verify that the key elements (e.g. events, clues, character revelations) appear in the text of the manuscript. Integrate this into the CLI as an optional review step (e.g. a flag `--review-draft` that triggers the validation routine). The `DraftValidator` can output a simple report listing any outline items that were not found in the draft or any inconsistencies (for example, a character that changed name again, or a subplot that was introduced but never resolved). This final QA step will ensure fidelity to the outline, and its report can be used for manual fixes or to improve prompts further. (As a future enhancement, this could even call an LLM in review mode to identify subtle omissions, but initially a direct string or ID matching approach is sufficient.)
* **Cost & Metrics Tracking:** Improve the CLI output to include a summary of resource usage and other metrics, which is especially useful given the multi-phase generation process. Extend the `CostLogger` (or create one if not present) to track the number of API calls and tokens consumed in each phase (premise expansion, characters, arc, subplots, beats, drafting, etc.). After the run, display a breakdown of the costs by phase and a total. For example: “Premise Expansion: 1 call, 500 tokens; Character Generation: 1 call, 750 tokens; ... Drafting: 20 calls, 15,000 tokens; **Total:** 25 calls, 20,000 tokens.” This helps developers and users understand the computational cost of a full run and identify any phases that are particularly expensive. Also consider logging the time taken per phase for performance insights.
* **Configuration & Tunable Settings:** Add a flexible configuration system to allow users or developers to adjust parameters for the generation process. Define a JSON schema (e.g. `novelist.config.schema.json`) and corresponding config file that can be supplied to the CLI. This config would include settings such as: max chapter length or target words per chapter, the number of retries to attempt if a beat is missing in a draft (for the guardrail logic), whether to enforce a specific point-of-view or tense throughout the narrative (e.g. always first-person past tense), and other stylistic or structural options. Implement a config loader that reads these settings and applies them in the relevant services (for instance, use the configured retry limit in the BeatCoverageValidator loop, or if a POV rule is set, append an instruction in each prompt enforcing that narrative perspective). By making these tunable, the tool becomes more adaptable to different project needs and user preferences.
* **Documentation Updates:** Update project documentation and examples to reflect all changes in phases 1–3. This includes revising the README.md to describe the new workflow order (character-first, subplot inclusion, etc.) and any new command-line flags or modes introduced (like `--review-draft`). Provide a sample project JSON file in the repository that demonstrates the new schema (with `ProjectMetadata`, `subplots`, `characterIds` in beats, etc.) so users can easily see the expected format. Document the configuration file usage and the available settings in `docs/` (for example, add a section in the README or a separate doc page about using the `novelist.config.json`). Ensure that any previous examples or tutorials are brought up-to-date with the new prompting approach and safeguards. Essentially, the documentation should enable a developer or end user to understand the enhanced pipeline and how to use the new features introduced in these three phases.

## Phase Implementation Sequence

To implement these changes methodically, proceed in three iterations corresponding to the phases, verifying stability at each step:

1. **Phase 1 (Continuity Recovery)** – Begin a new branch (e.g. `phase-1-continuity`) and implement all Phase 1 fixes: reordering the generation steps, schema updates for IDs, and basic validation. Once completed, run the tool end-to-end on a sample project to ensure it still produces an outline and draft without errors (and that character names now remain consistent). Merge these changes back to the main branch only after verification.
2. **Phase 2 (Prompt Scaffolding & Guard-rails)** – On a fresh branch (e.g. `phase-2-scaffolds`), add the subplot generation, iterative beat prompting, context-rich chapter planning, and new guardrails. After implementing, test the full outline generation again: the outline JSON should now contain subplots, beats with character references, etc., and the draft generation should include the new prompt structures. Verify that all outlined beats are present in the draft (the new validators should help ensure this). Refine as needed, then merge when the system produces a complete, coherent outline and draft.
3. **Phase 3 (Fidelity & Polishing)** – Finally, on a `phase-3-fidelity` branch, upgrade the drafting engine to chapter-by-chapter mode, introduce the post-draft validation, metrics logging, and config file support. Conduct full runs to ensure that the final manuscript is faithful to the outline (use the `--review-draft` to get a QA report and confirm no beats are missing). Check that the cost logging and new CLI options work as expected. Once everything looks stable and the output is consistently high fidelity, merge these changes and prepare for a beta release.

Each phase should result in a working build that passes all existing tests (and any new ones added for these features) and generates a story end-to-end with improvements from that phase. Only proceed to the next phase after stabilizing the previous one. This phased approach will make it easier to isolate and fix any issues introduced at each stage, ultimately leading to a robust and consistent **Novelist** pipeline that preserves story context and adheres to the outline from start to finish.
